{"version":3,"sources":["file:///Users/ruoyan/Desktop/WorkSpace/LegendOfWarcraftHeroes/assets/script/util/sundry/moveNodeToPosition.ts"],"names":["moveNodeToPosition","node","option","moveCurve","forbidRotation","moveTimeScale","originPosition","x","position","y","curveFunc","moveX","targtePosition","timesAmount","moveY","currentPosition","Promise","res","setPosition","targetPosition","z","times","nextPosition","inter","setInterval","clearInterval","angle","Math","atan"],"mappings":"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","sourcesContent":["import { Node, Vec2, math } from \"cc\";\n\ntype Coordinate = {\n    x:number ,\n    y: number\n}\n\ntype CurveFuncOption = {\n    // 总动画次数\n    timesAmount: number ,\n    // 当前动画次数\n    times: number ,\n    // 最开始的位置\n    originPosition: Coordinate ,\n    // 目标坐标\n    targtePosition: Coordinate ,\n    // 当前坐标\n    currentPosition: Coordinate ,\n}\n\nexport type MoveNodeToPositionOption = {\n\n    // 移动目标方位\n    targetPosition: Coordinate ,\n\n    // 曲率函数用于计算每一帧的落点 默认为直线\n    curveFunc?: (option: CurveFuncOption) => Coordinate ,\n    \n    // 禁用节点旋转 默认true\n    forbidRotation?: boolean ,\n\n    // 是否移动曲线 默认 false\n    moveCurve?: boolean ,\n\n    // 移动速度 默认 1\n    moveTimeScale?: number\n}\n\n/** \n * 将某个节点移动到某个坐标\n * @param node 要移动的节点\n * @param option 移动配置\n */\nexport async function moveNodeToPosition(node: Node, option: MoveNodeToPositionOption) {\n    option.moveCurve = option.moveCurve || false\n    option.forbidRotation = option.forbidRotation || true\n    option.moveTimeScale = option.moveTimeScale || 1\n    const originPosition = {x: node.position.x , y: node.position.y}\n    option.curveFunc = option.curveFunc || ((option: CurveFuncOption) => {\n        const moveX = (option.targtePosition.x - originPosition.x) / option.timesAmount\n        const moveY = (option.targtePosition.y - originPosition.y) / option.timesAmount\n        return {x: option.currentPosition.x + moveX , y: option.currentPosition.y + moveY}\n    })\n    return new Promise<void>(res => {\n        // 不使用曲线\n        if (!option.moveCurve) {\n            node.setPosition(\n                option.targetPosition.x ,\n                option.targetPosition.y ,\n                node.position.z\n            )\n            return res()\n        }\n        let times = 0\n        let nextPosition: {x:number , y: number} = {\n            x: node.position.x ,\n            y: node.position.y\n        }\n        // 使用曲线\n        const inter = setInterval(() => {\n            const timesAmount = 25\n            if (times >= timesAmount) {\n                clearInterval(inter)\n                return res()\n            }\n            // 设置相对于下上一帧进行旋转\n            if (!option.forbidRotation)\n                node.angle = Math.atan((nextPosition.x - node.position.x) / (nextPosition.y - node.position.y))\n            // 设置位置\n            node.setPosition(nextPosition.x , nextPosition.y)\n            // 次数加一\n            times++\n            // 计算下一帧的位置\n            nextPosition = option.curveFunc({\n                times ,\n                timesAmount ,\n                originPosition: originPosition ,\n                targtePosition: option.targetPosition ,\n                currentPosition: {x: node.position.x , y: node.position.y} ,\n            })\n        } , 16 / option.moveTimeScale)\n    })\n}"]}